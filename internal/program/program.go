// Package program wraps the initial interaction with the end user, before (if
// ever) the control is passed to the tea.Program.
package program

import (
	"flag"
	"fmt"
	"io"
	"log"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/orlangure/gocovsh/internal/model"
)

const (
	defaultProfileFilename = "coverage.out"
)

// New return a new Program instance. Optional configuration is available using
// `With...` functions.
func New(opts ...Option) *Program {
	p := &Program{
		output:  os.Stdout,
		flagSet: flag.CommandLine,
		args:    os.Args[1:],
	}

	for _, opt := range opts {
		opt(p)
	}

	p.flagSet.BoolVar(&p.showVersion, "version", false, "show version")
	p.flagSet.StringVar(
		&p.profileFilename, "profile", defaultProfileFilename,
		"File name of coverage profile generated by go test -coverprofile coverage.out",
	)

	return p
}

// Program holds the program configuration.
type Program struct {
	version string
	commit  string
	date    string

	showVersion     bool
	profileFilename string

	flagSet *flag.FlagSet
	args    []string
	output  io.Writer
	logFile string
}

// Run parses the command line arguments and runs the program.
func (p *Program) Run() error {
	if err := p.flagSet.Parse(p.args); err != nil {
		return fmt.Errorf("failed to parse flags: %w", err)
	}

	if p.showVersion {
		_, err := fmt.Fprintf(
			p.output,
			"Version: %s\nCommit: %s\nDate: %s\n",
			p.version, p.commit, p.date,
		)

		return err
	}

	m := model.New(model.WithProfileFilename(p.profileFilename))

	if p.logFile != "" {
		f, err := tea.LogToFile(p.logFile, "gocovsh")
		if err != nil {
			return fmt.Errorf("failed to setup logger: %w", err)
		}

		defer func() { _ = f.Close() }()

		log.Println("logging to", p.logFile)
	}

	if err := tea.NewProgram(m, tea.WithAltScreen()).Start(); err != nil {
		return fmt.Errorf("failed to start program: %w", err)
	}

	return nil
}
